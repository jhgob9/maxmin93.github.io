---
title: "Effective Java 3rd - Ch06"
date: 2019-03-23 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제6장 열거 타입과 애너테이션 

자바에는 특수한 목적의 참조타입이 두가지 있다

- 클래스의 일종인 열거 타입(enum)
- 인터페이스의 일종인 애너테이션(annotation)

 
## 34) int 상수 대신 `enum 타입`을 사용하라 

열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입

> 코드 34-1 정수 열거 패턴 - 상당히 취약하다 

```java
public static final int APPLE_FUJI				 = 0;
public static final int APPLE_PIPPIN			 = 1;
public static final int APPLE_GRANNY_SMITH = 2;

public static final int ORANGE_NAVEL 	   	 = 0;
public static final int ORANGE_TEMPLE	   	 = 1;
public static final int ORANGE_BLOOD 	   	 = 2;
```

`정수 열거 패턴` 기법에는 단점이 많다

- 타입 안전을 보장할 방법이 없고 표현력도 좋지 않다
	- ex) 오렌지를 보내야할 메서드에 사과를 보내고 비교를 해도 경고가 없다
	- ex) 같은 이름의 수은(원소)과 수성(행성)을 구분하기 위해 접두어를 붙여야 한다
- 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다 
	- 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일 해야 한다
- 정수 상수는 문자열로 출력하기가 다소 까다롭다 (특히 디버깅때)
- 정수 대신 문자열을 사용하는 `문자열 열거 패턴`은 더 나쁘다 
	- 문자열 값을 그대로 하드 코딩하게 만들어 오타로 런타임 오류 가능
	- 문자열 비교로 인한 성능 저하 

> 코드 34-2 가장 단순한 열거 타입

```java
public enum Apple  { FUJI, PIPPIN, GRANNY_SMITH };
public enum Orange { NAVEL, TEMPLE, BLOOD };
```

#### 자바의 열거 타입은 완전한 형태의 클래스라서 다른 언어의 열거 타입보다 훨씬 강력하다

- 열거 타입 자체는 클래스
- 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개
	- 사실상 final
- 싱글턴을 일반화한 형태라고 볼 수 있음
	- 반대로 싱글턴은 원소가 하나뿐인 열거 타입
- 컴파일타임 타입 안전성을 제공
- 각자의 이름 공간이 있어서 같은 이름의 상수도 공존
- :exclamation: 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수도 있다
	- 상수에 연관된 데이터를 내재시킬 수 있음, ex) Apple, Orange 의 색 또는 이미지 반환
- :exclamation: Object 메서드를 구현해 놓았고, Comparable 과 Serializable 을 구현해 놓았음 

> 코드 34-3 데이터와 메서드를 갖는 열거 타입

```java
public enum Planet {

	// 항목 변경시, 특히 삭제시 사용측(클라이언트)에 명확한 오류 메시지를 출력한다
  MERCURY(3.302e+23, 2.439e6),
  VENUS  (4.869e+24, 6.052e6),
  EARTH  (5.975e+24, 6.378e6),
  MARS   (6.419e+23, 3.393e6),
  JUPITER(1.899e+27, 7.149e7),
  SATURN (5.685e+26, 6.027e7),
  URANUS (8.683e+25, 2.556e7),
  NEPTUNE(1.024e+26, 2.477e7);

  // **NOTE: enum 항목들의 멤버로 포함된다

  private final double mass;           // 질량(단위: 킬로그램)
  private final double radius;         // 반지름(단위: 미터)
  private final double surfaceGravity; // 표면중력(단위: m / s^2)

  // 중력상수(단위: m^3 / kg s^2)
  private static final double G = 6.67300E-11;

  // 생성자에서 항목별 멤버들의 값을 저장
  Planet(double mass, double radius) {
      this.mass = mass;
      this.radius = radius;
      surfaceGravity = G * mass / (radius * radius);
  }

  // 필드를 public 으로 하는 것보다 접근자 메서드를 두는게 낫다 
  public double mass()           { return mass; }
  public double radius()         { return radius; }
  public double surfaceGravity() { return surfaceGravity; }

  public double surfaceWeight(double mass) {
      return mass * surfaceGravity;  // F = ma
  }	
}

/////////////////////////

public class WeightTable {
	public static void main(String[] args) {
		double earthWeight = Double.parseDouble( args[0] );
		double mass = earthWeight / Planet.EARTH.surfaceGravity();
		for( Planet p : Planet.values() )		// enum 의 모든 항목 순회 
			System.out.printf("%s 에서의 무게는 %f 이다.%n", p, p.surfaceWeight(mass));
	}
}
```

#### 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다

> 코드 34-4 값에 따라 분기하는 열거 타입 - 이대로 만족하는가?

```java
public enum Operation {
  PLUS, MINUS, TIMES, DIVIDE;

  // 상수가 뜻하는 연산을 수행한다
  public double apply(double x, double y) {
  	// **NOTE: 깨지기 쉬운 코드 ==> 항목이 변하면 switch 문도 변경해야 함
  	switch(this) {
  		case PLUS : 		return x + y;
  		case MINUS : 		return x - y;
  		case TIMES : 		return x * y;
  		case DIVIDE : 	return x / y;
  	}
  	throw new AssertionError("알 수 없는 연산: "+this);
  }
}
```

> 코드 34-5 상수별 메서드 구현을 활용한 열거 타입

```java
public enum Operation {
  PLUS {
      public double apply(double x, double y) { return x + y; }
  },
  MINUS {
      public double apply(double x, double y) { return x - y; }
  },
  TIMES {
      public double apply(double x, double y) { return x * y; }
  },
  DIVIDE {
      public double apply(double x, double y) { return x / y; }
  };

  public abstract double apply( double x, double y );
}  
```

> 코드 34-6 상수별 클래스 몸체(body)와 데이터를 사용한 열거 타입 

```java
public enum Operation {
  PLUS("+") {
      public double apply(double x, double y) { return x + y; }
  },
  MINUS("-") {
      public double apply(double x, double y) { return x - y; }
  },
  TIMES("*") {
      public double apply(double x, double y) { return x * y; }
  },
  DIVIDE("/") {
      public double apply(double x, double y) { return x / y; }
  };

  private final String symbol;

  Operation(String symbol) { this.symbol = symbol; }

  @Override public String toString() { return symbol; }

  public abstract double apply(double x, double y);
}

////////////////////////////

public static void main(String[] args) {
  double x = Double.parseDouble(args[0]);
  double y = Double.parseDouble(args[1]);
  for( Operation op : Operation.values() )
    System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
}
```

> 코드 34-7 열거 타입용 fromString 메서드 구현하기 

```java
  private static final Map<String, Operation> stringToEnum =
          Stream.of(values()).collect(
                  toMap(Object::toString, e -> e));

  // 지정한 문자열에 해당하는 Operation을 (존재한다면) 반환한다.
  public static Optional<Operation> fromString(String symbol) {
      return Optional.ofNullable(stringToEnum.get(symbol));
  }
```

> 코드 34-8 값에 따라 분기하여 코드를 공유하는 열거 타입 - 좋은 방법인가?

```java
```

> 코드 34-9 값에 따라 분기하여 코드를 공유하는 열거 타입 - 좋은 방법인가?

```java
```

> 코드 34-10 값에 따라 분기하여 코드를 공유하는 열거 타입 - 좋은 방법인가?

```java
```


## 35) ordinal 메서드 대신 `인스턴스 필드`를 사용하라 

```java
```

## 36) 비트 필드 대신 `EnumSet`을 사용하라 

```java
```

## 37) ordinal 인덱싱 대신 `EnumSet`을 사용하라 

```java
```

## 38) 확장할 수 있는 열거 타입이 필요하면 `인터페이스`를 사용하라 

```java
```

## 39) 명명 패턴보다 `애너테이션`을 사용하라 

```java
```

## 40) `@Override` 애너테이션을 일관되게 사용하라 

```java
```

## 41) 정의하려는 것이 타입이라면 `마커 인터페이스`를 사용하라 

```java
```

