---
title: "Effective Java 3rd - Ch04"
date: 2019-03-16 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제4장 클래스와 인터페이스

- 추상화의 기본 단위인 클래스와 인터페이스는 자바 언어의 심장과 같다
- 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내한다


## 15) 클래스와 멤버의 `접근 권한`을 최소화 하라

```java
// 보안 허점이 숨어 있다
public static final Thing[] VALUES = { ... };

// 해결책 1) public 배열을 private 으로 만들고, public 불변 리스트를 추가
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES =
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// 해결책 2) 배열을 private 으로 만들고, 그 복사본을 반환하는 public 메소드를 추가 (방어적 복사)
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
  return PRIVATE_VALUES.clone();
}
```

> :heavy_exclamation_mark: 핵심정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
  - 꼭 필요한 것만 골라 최소한의 public API 를 설계
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다
  - public static final 필드가 참조하는 객체가 불변인지 확인하라


## 16) public 클래스에서는 public 필드가 아닌 `접근자 메서드`를 사용하라

> 코드 16-1 이처럼 퇴보한 클래스는 public 이어서는 안된다

```java
class Point {
  public double x;
  public double y;
}
```

> 코드 16-2 접근자와 변경자(mutator) 메서드를 활용해 데이터를 `캡슐화`한다

```java
class Point {
  private double x;
  private double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  public double getX() { return x; }
  public double getY() { return y; }

  public void setX(double x) { this.x = x; }
  public void setY(double y) { this.y = y; }
}
```

> 코드 16-3 불변 필드를 노출한 public 클래스 : 과연 좋은가?

```java
public final class Time {
  private static final int HOURS_PER_DAY    = 24;
  private static final int MINUTES_PER_HOUR = 60;

  // 좋은건 아닌데 괜찮다
  public final int hour;
  public final int minute;

  public Time(int hour, int minute) {
    if( hour < 0 || hour >= HOURS_PER_DAY )
      throw new IllegalArgumentException("시간: "+hour);
    if( minute < 0 || minute >= MINUTES_PER_HOUR )
      throw new IllegalArgumentException("분: "+minute);
    this.hour = hour;
    this.minute = minute;
  }

  ... // 생략
}

```

> :heavy_exclamation_mark: 핵심정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다
  - 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다
- 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다

## 17) `변경 가능성`을 최소화 하라

클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 따르면 된다

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
- 클래스를 확장할 수 없도록 한다
- 모든 필드를 final 로 선언한다
- 모든 필드를 private 으로 선언한다
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다

> 코드 17-1 불변 복소수 클래스

```java
public final class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  public double realPart() { return re; }
  public double imaginaryPart() { return im; }

  public Complex plus(Complex c) {
    return new Complex(re + c.re, im + c.im);
  }
  public Complex minus(Complex c) {
    return new Complex(re - c.re, im - c.im);
  }
  public Complex times(Complex c) {
    return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
  }
  public Complex dividedBy(Complex c) {
    double tmp = c.re * c.re + c.im * c.im;
    return new Complex( (re * c.re - im * c.im)/tmp,
                    , (im * c.re - re * c.im)/tmp);
  }

  @Override public boolean equals(Object o) {
    if( o == this ) return true;
    if( !(o instanceof Complex)) return false;
    Complex c = (Complex) o;

    // == 대신 compare 를 사용하는 이유는 63쪽을 확인하라
    return Double.compare(c.re, re) == 0 && Double.compare(c.im, im) == 0;
  }

  @Override public int hashCode() {
    return 31 * Double.hashCode(re) + Double.hashCode(im);
  }

  @Override public String toString() {
    return "(" + re + " + " + im + "i)";
  }
}
```

> 63쪽 : float 와 double 을 특별 취급하는 이유

- Float.NaN, -0.0f, `특수한 부동소수 값` 등을 다뤄야 하기 때문이다
- Float.equals 와 Double.equals 메서드는 `오토박싱`을 수반할 수 있으니 성능상 좋지 않다

> 코드 17-2 생성자 대신 정적 팩토리를 사용한 불변 클래스

```java
public class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  // 정적 팩토리 valueOf
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }

  ... // 생략
}
```


## 18) 상속보다는 `컴포지션`을 사용하라

> 코드 18-1 잘못된 예 : 상속을 잘못 사용했다

```java
public class InstrumentedHashSet<E> extends HashSet<E> {
  // 추가된 원소의 수
  private int addCount = 0;

  public InstrumentedHashSet() {}
  public InstrumentedHashSet(int initCap, float loadFactor) {
    super(initCap, loadFactor);
  }

  @Override public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  @Override public boolean addAll(Collection<? extends E> c) {
    addCount += c.size();
    return super.addAll(c);
  }

  public int getAddCount() {
    return addCount;
  }
}
```

> 코드 18-2 래퍼 클래스 : 상속 대신 컴포지션을 사용했다

```java
public class InstrumentedHashSet<E> extends ForwardingSet<E> {
  // 추가된 원소의 수
  private int addCount = 0;

  public InstrumentedHashSet(Set<E> s) {
    super(s);
  }

  @Override public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  @Override public boolean addAll(Collection<? extends E> c) {
    addCount += c.size();
    return super.addAll(c);
  }

  public int getAddCount() {
    return addCount;
  }
}
```

> 코드 18-3 재사용 할 수 있는 전달 클래스

```java
public class ForwardingSet<E> implements Set<E> {
  private final Set<E> s;
  public ForwardingSet(Set<E> s) { this.s = s; }

  public void clear()               { s.clear(); }
  public boolean contains(Object o) { return s.contains(o); }
  public boolean isEmpty()          { return s.isEmpty(); }
  public int size()                 { return s.size(); }
  public Iterator<E> iterator()     { return s.iterator(); }
  public boolean add(E e)           { return s.add(e); }
  public boolean remove(Object o)   { return s.remove(o); }
  public boolean containsAll(Collection<?> c)     { return s.containsAll(c); }
  public boolean addAll(Collection<? extends E> c){ return s.addAll(c); }
  public boolean removeAll(Collection<?> c)       { return s.removeAll(c); }
  public boolean retainAll(Collection<?> c)       { return s.retainAll(c); }
  public Object[] toArray())        { return s.toArray(); }
  public <T> T[] toArray(T[] a)     { return s.toArray(a); }

  @Override public boolean equals(Object o)) { return s.equals(o); }
  @Override public int hashCode() { return s.hashCode(); }
  @Override public String toString() { return s.toString(); }
}
```

## 19) `상속`을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라

```java
public class Super {
  // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다
  public Super() {
    overrideMe();
  }
  public void overrideMe() {
  }
}

//////////////////////

public final class Sub extends Super {
  // 초기화 되지 않은 final 필드. 생성자에서 초기화 한다
  private final Instant instant;

  Sub() {
    instant = Instant.now();
  }

  // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다
  @Override public void overrideMe() {
    System.out.println(instant);
  }

  public static void main(String[] args) {
    Sub sub = new Sub();
    sub.overrideMe();
    // instant 를 두번 출력할 줄 알았지만, 첫번째는 null 을 출력한다
    // ==> 상위 클래스의 생성자는 하위 클래스의 생성자가
    //   인스턴스 필드를 초기화 하기도 전에 overrideMe 를 호출하기 때문
  }
}
```

## 20) 추상 클래스보다는 `인터페이스`를 우선하라

> 코드 20-1 골격 구현을 사용해 완성한 구체 클래스

```java
static List<Integer> intArrayAsList(int[] a) {
  Objects.requiredNonNull(a);

  // 다이아몬드 연산자를 이렇게 사용하는 건 자바9 부터 가능하다
  // 더 낮은 버전을 사용한다면 <Integer>로 수정하자
  return new AbstractList<>() {
    @Override public Integer get(int i) {
      return a[i];      // 오토 박싱
    }
    @Override public Integer set(int i, Integer val) {
      int oldVal = a[i];
      a[i] = val;       // 오토 언박싱
      return oldVal;    // 오토 박싱
    }
    @Override public int size() {
      return a.length;
    }
  };
}
```

> 코드 20-2 골격 구현 클래스

```java
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {

  // 변경 가능한 엔트리는 이 메서드를 반드시 재정의 해야 한다
  @Override public V setValue(V value) {
    throw new UnsupportedOperationException();
  }

  // Map.Entry.equals 의 일반 규약을 구현한다
  @Override public boolean equals(Object o) {
    if( o == this ) return true;
    if( !(o instanceof Map.Entry)) return false;
    Map.Entry<?,?> e = (Map.Entry) o;
    return Objects.equals(e.getKey(), getKey())
        && Objects.equals(e.getValue(), getValue());
  }

  // Map.Entry.hashCode 의 일반 규약을 구현한다
  @Override public int hashCode() {
    return Objects.hashCode(getKey())
          ^ Objects.hashCode(getValue());
  }

  @Override public String toString() {
    return getKey() + "=" + getValue();
  }  
}
```

Map.Entry 인터페이스나 그 하위 인터페이스로는 이 골격 구현을 제공할 수 없다. 디폴트 메서드는 equals, hashCode, toString 같은 Object 메서드를 재정의 할 수 없기 때문이다.



## 21) 인터페이스는 `구현하는 쪽`을 생각해 설계하라

> 코드 21-1 자바8의 Collection 인터페이스에 추가된 디폴트 메서드

```java
default boolean removeIf(Predicate<? super E> filter) {
  Objects.requiredNonNull(filter);
  boolean result = false;
  for( Iterator<E> it = iterator(); it.hasNext(); ) {
    if( filter.test(it.next()) ) {
      it.remove();
      result = true;
    }
  }
  return result;
}
```

## 22) 인터페이스는 `타입을 정의`하는 용도로만 사용하라

인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.

> 코드 22-1 상수 인터페이스 안티패턴 - 사용 금지!

```java
// 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예이다
public interface PhysicalConstants {

  // 아보가드로 수 (1/몰)
  static final double AVOGADROS_NUMBER    = 6.022_140_857e23;
  // 볼츠만 상수 (J/K)
  static final double BOLTZMANN_CONSTANT  = 1.380_648_52e-23;
  // 전자 질량 (kg)
  static final double ELECTRON_MASS       = 9.109_383_56e-31;
}
```

> 코드 22-2 상수 유틸리티 클래스

```java
package effectivejava.chapter4.item22.constantutilityclass;

public class PhysicalConstants {
  private PhysicalConstants() {}    // 인스턴스화 방지

  // 아보가드로 수 (1/몰)
  static final double AVOGADROS_NUMBER    = 6.022_140_857e23;
  // 볼츠만 상수 (J/K)
  static final double BOLTZMANN_CONSTANT  = 1.380_648_52e-23;
  // 전자 질량 (kg)
  static final double ELECTRON_MASS       = 9.109_383_56e-31;
}

// 숫자 리터럴에 사용한 밑줄(_)
// ==> 자바7부터 허용되는 이 밑줄은 숫자 리터럴의 값에는 아무런 영향을 주지 않으면서
//    읽기는 훨씬 편하게 해준다. (고정소수든 부동소수든) 5자리 이상이라면 밑줄 사용을 권한다.
//    십진수 리터럴도 (정수든 부동소수든) 세자리씩 묶어주는 것이 좋다.
```

> 코드 22-3 정적 임포트를 사용해 상수 이름만으로 사용하기

```java
// PhysicalConstants 를 빈번히 사용한다면 정적 임포트가 값어치를 한다
import static effectivejava.chapter4.item22.constantutilityclass.PhysicalConstants.*;

public class Test {
  double atoms(double mols) {
    return AVOGADROS_NUMBER * mols;
  }
  ... // 생략
}
```

## 23) 태그 달린 클래스보다는 `클래스 계층구조`를 활용하라

```java
```

## 24) 멤버 클래스는 되도록 `static` 으로 만들어라

```java
```

## 25) Top 레벨 클래스는 `한 파일에 하나`만 담으라

```java
```
