---
title: "Effective Java 3rd - Ch04"
date: 2019-03-16 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제4장 클래스와 인터페이스

- 추상화의 기본 단위인 클래스와 인터페이스는 자바 언어의 심장과 같다
- 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내한다


## 15) 클래스와 멤버의 `접근 권한`을 최소화 하라

```java
// 보안 허점이 숨어 있다
public static final Thing[] VALUES = { ... };

// 해결책 1) public 배열을 private 으로 만들고, public 불변 리스트를 추가
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES =
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// 해결책 2) 배열을 private 으로 만들고, 그 복사본을 반환하는 public 메소드를 추가 (방어적 복사)
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
  return PRIVATE_VALUES.clone();
}
```

> :heavy_exclamation_mark: 핵심정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
  - 꼭 필요한 것만 골라 최소한의 public API 를 설계
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다
  - public static final 필드가 참조하는 객체가 불변인지 확인하라


## 16) public 클래스에서는 public 필드가 아닌 `접근자 메서드`를 사용하라

> 코드 16-1 이처럼 퇴보한 클래스는 public 이어서는 안된다

```java
class Point {
  public double x;
  public double y;
}
```

> 코드 16-2 접근자와 변경자(mutator) 메서드를 활용해 데이터를 `캡슐화`한다

```java
class Point {
  private double x;
  private double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  public double getX() { return x; }
  public double getY() { return y; }

  public void setX(double x) { this.x = x; }
  public void setY(double y) { this.y = y; }
}
```

> 코드 16-3 불변 필드를 노출한 public 클래스 : 과연 좋은가?

```java
public final class Time {
  private static final int HOURS_PER_DAY    = 24;
  private static final int MINUTES_PER_HOUR = 60;

  // 좋은건 아닌데 괜찮다
  public final int hour;
  public final int minute;

  public Time(int hour, int minute) {
    if( hour < 0 || hour >= HOURS_PER_DAY )
      throw new IllegalArgumentException("시간: "+hour);
    if( minute < 0 || minute >= MINUTES_PER_HOUR )
      throw new IllegalArgumentException("분: "+minute);
    this.hour = hour;
    this.minute = minute;
  }

  ... // 생략
}

```

> :heavy_exclamation_mark: 핵심정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다
  - 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다
- 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다

## 17) `변경 가능성`을 최소화 하라

클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 따르면 된다

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
- 클래스를 확장할 수 없도록 한다
- 모든 필드를 final 로 선언한다
- 모든 필드를 private 으로 선언한다
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다

> 코드 17-1 불변 복소수 클래스

```java
public final class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  public double realPart() { return re; }
  public double imaginaryPart() { return im; }

  public Complex plus(Complex c) {
    return new Complex(re + c.re, im + c.im);
  }
  public Complex minus(Complex c) {
    return new Complex(re - c.re, im - c.im);
  }
  public Complex times(Complex c) {
    return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
  }
  public Complex dividedBy(Complex c) {
    double tmp = c.re * c.re + c.im * c.im;
    return new Complex( (re * c.re - im * c.im)/tmp,
                    , (im * c.re - re * c.im)/tmp);
  }

  @Override public boolean equals(Object o) {
    if( o == this ) return true;
    if( !(o instanceof Complex)) return false;
    Complex c = (Complex) o;

    // == 대신 compare 를 사용하는 이유는 63쪽을 확인하라
    return Double.compare(c.re, re) == 0 && Double.compare(c.im, im) == 0;
  }

  @Override public int hashCode() {
    return 31 * Double.hashCode(re) + Double.hashCode(im);
  }

  @Override public String toString() {
    return "(" + re + " + " + im + "i)";
  }
}
```

> 63쪽 : float 와 double 을 특별 취급하는 이유

- Float.NaN, -0.0f, `특수한 부동소수 값` 등을 다뤄야 하기 때문이다
- Float.equals 와 Double.equals 메서드는 `오토박싱`을 수반할 수 있으니 성능상 좋지 않다

> 코드 17-2 생성자 대신 정적 팩토리를 사용한 불변 클래스

```java
public class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  // 정적 팩토리 valueOf
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }

  ... // 생략
}
```


## 18) 상속보다는 `컴포지션`을 사용하라

> 코드 18-1 잘못된 예 : 상속을 잘못 사용했다

```java
public class InstrumentedHashSet<E> extends HashSet<E> {
  // 추가된 원소의 수
  private int addCount = 0;

  public InstrumentedHashSet() {}
  public InstrumentedHashSet(int initCap, float loadFactor) {
    super(initCap, loadFactor);
  }

  @Override public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  @Override public boolean addAll(Collection<? extends E> c) {
    addCount += c.size();
    return super.addAll(c);
  }

  public int getAddCount() {
    return addCount;
  }
}
```

> 코드 18-2 래퍼 클래스 : 상속 대신 컴포지션을 사용했다

```java
public class InstrumentedHashSet<E> extends ForwardingSet<E> {
  // 추가된 원소의 수
  private int addCount = 0;

  public InstrumentedHashSet(Set<E> s) {
    super(s);
  }

  @Override public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  @Override public boolean addAll(Collection<? extends E> c) {
    addCount += c.size();
    return super.addAll(c);
  }

  public int getAddCount() {
    return addCount;
  }
}
```

> 코드 18-3 재사용 할 수 있는 전달 클래스

```java
public class ForwardingSet<E> implements Set<E> {
  private final Set<E> s;
  public ForwardingSet(Set<E> s) { this.s = s; }

  public void clear()               { s.clear(); }
  public boolean contains(Object o) { return s.contains(o); }
  public boolean isEmpty()          { return s.isEmpty(); }
  public int size()                 { return s.size(); }
  public Iterator<E> iterator()     { return s.iterator(); }
  public boolean add(E e)           { return s.add(e); }
  public boolean remove(Object o)   { return s.remove(o); }
  public boolean containsAll(Collection<?> c)     { return s.containsAll(c); }
  public boolean addAll(Collection<? extends E> c){ return s.addAll(c); }
  public boolean removeAll(Collection<?> c)       { return s.removeAll(c); }
  public boolean retainAll(Collection<?> c)       { return s.retainAll(c); }
  public Object[] toArray())        { return s.toArray(); }
  public <T> T[] toArray(T[] a)     { return s.toArray(a); }

  @Override public boolean equals(Object o)) { return s.equals(o); }
  @Override public int hashCode() { return s.hashCode(); }
  @Override public String toString() { return s.toString(); }
}
```

## 19) `상속`을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라

```java
```

## 20) 추상 클래스보다는 `인터페이스`를 우선하라

```java
```

## 21) 인터페이스는 `구현하는 쪽`을 생각해 설계하라

```java
```

## 22) 인터페이스는 `타입을 정의`하는 용도로만 사용하라

```java
```

## 23) 태그 달린 클래스보다는 `클래스 계층구조`를 활용하라

```java
```

## 24) 멤버 클래스는 되도록 `static` 으로 만들어라

```java
```

## 25) Top 레벨 클래스는 `한 파일에 하나`만 담으라

```java
```
