---
title: "Effective Java 3rd - Ch07"
date: 2019-03-27 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제7장 람다와 스트림

- 자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되면서 `함수 객체`를 더 쉽게 만들 수 있게 됨
- 스트림 API 도 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작  


## 42) 익명 클래스보다는 `람다`를 사용하라 

예전에는 추상 메서드를 하나만 담은 인터페이스를 함수 타입으로 사용했다. (함수 객체)

> 코드 42-1 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법이다

```java
Collections.sort(words, 
  // 익명 클래스 : 코드가 길기 때문에 함수형 프로그래밍에 적합하지 않음
  new Comparator<String>(){       // 정렬을 담당하는 추상 전략
    public int compare(String s1, String s2) {
      return Integer.compare(s1.length(), s2.length());
    }
});
```

자바 8에 와서 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 람다식을 이용해 만들게 되었다.

> 코드 42-2 람다식을 함수 객체로 사용 - 익명 클래스 대체

```java
// 컴파일러가 대신 문맥을 살펴 타입을 추론
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));

// 람다 자리에 비교자 생성 메서드를 사용하면 더 간결해진다
Collections.sort(words, comparingInt(String::length));

// 자바 8에서 List 인터페이스에 추가된 sort 메서드를 이용하면 더 짧아진다
words.sort( comparingInt(String::length));
```

:hand: [Guide to Java 8 - Comparator.comparing()](https://www.baeldung.com/java-8-comparator-comparing)

타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.


> 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입

```java
public enum Operation {
/*
  // >> 코드 42-3
  // 코드 34-6 에서는 상수별 클래스를 이용해 apply 메서드를 재정의 했었다
  PLUS("+") {
      public double apply(double x, double y) { return x + y; }
  },
  MINUS("-") {
      public double apply(double x, double y) { return x - y; }
  },
  TIMES("*") {
      public double apply(double x, double y) { return x * y; }
  },
  DIVIDE("/") {
      public double apply(double x, double y) { return x / y; }
  };

  Operation(String symbol) { this.symbol = symbol; }
*/

  // 람다는 한줄일 때 가장 좋고 길어야 세줄 안에 끝내는 것이 좋다
  // 계산식이 여러줄이라면 상수별 익명 클래스를 사용해야 한다

  // DoubleBinaryOperator 함수 인터페이스로 계산식을 정의
  // **NOTE: 두개의 double 입력을 받아 double 출력하는 함수 형식
  PLUS  ("+", (x, y) -> x + y),   // 계산식을 람다로 구성해 생성자에 넘긴다 
  MINUS ("-", (x, y) -> x - y),
  TIMES ("*", (x, y) -> x * y),
  DIVIDE("/", (x, y) -> x / y);

  // DoubleBinaryOperator : Double 타입 인수 2개를 받아 Double 타입 결과를 돌려준다 
  private final DoubleBinaryOperator op;    // 계산식의 함수 객체 (멤버) 
  private final String symbol;

  Operation(String symbol, DoubleBinaryOperator op) {
    this.symbol = symbol;
    this.op = op;
  }

  @Override public String toString() { return symbol; }

  public double apply(double x, double y) {
    return op.applyAsDouble(x, y);
  }
}

//////////////////////////////////////////

// 아이템 34의 메인 메서드 (215쪽)
public static void main(String[] args) {
  double x = Double.parseDouble(args[0]);
  double y = Double.parseDouble(args[1]);
  for (Operation op : Operation.values())
    System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
}
```

메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.

```java
// 함수 객체로 정렬하기 (254-255쪽)
public class SortFourWays {
    public static void main(String[] args) {
        List<String> words = Arrays.asList(args);

        // 코드 42-1 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법이다! (254쪽)
        Collections.sort(words, new Comparator<String>() {
            public int compare(String s1, String s2) {
                return Integer.compare(s1.length(), s2.length());
            }
        });
        System.out.println(words);
        Collections.shuffle(words);

        // 코드 42-2 람다식을 함수 객체로 사용 - 익명 클래스 대체 (255쪽)
        Collections.sort(words,
                (s1, s2) -> Integer.compare(s1.length(), s2.length()));
        System.out.println(words);
        Collections.shuffle(words);

        // 람다 자리에 비교자 생성 메서드(메서드 참조와 함께)를 사용 (255쪽)
        Collections.sort(words, comparingInt(String::length));
        System.out.println(words);
        Collections.shuffle(words);

        // 비교자 생성 메서드와 List.sort를 사용 (255쪽)
        words.sort(comparingInt(String::length));
        System.out.println(words);
    }
}
```

:exclamation: 핵심 정리

익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라. 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어 (이전 자바에서는 실용적이지 않던) 함수형 프로그래밍의 지평을 열었다.



## 43) 람다보다는 `메서드 참조`를 사용하라 

람다가 익명 클래스보다 간결하고, 메서드 참조는 람다보다 더 간결하다.

```java
// merge 메서드는 '키/값/함수'를 인수로 받으며
// 주어진 키가 맵 안에 아직 없다면 주어진 {키,값} 쌍을 그대로 저장한다.
// 반대로 키가 이미 있다면 함수를 현재 값과 주어진 값에 적용한 다음, 결과로 현재 값을 덮어쓴다 
map.merge(key, 1, (count, incr) -> count + incr);

// 자바 8에서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드 'sum'을 제공하기 시작했다
map.merge(key, 1, Integer::sum);
```

:point_right: 사용 예제

```java
// map.merge를 이용해 구현한 빈도표 - 람다 방식과 메서드 참조 방식을 비교해보자. (259쪽)
public class Freq {
  public static void main(String[] args) {
    Map<String, Integer> frequencyTable = new TreeMap<>();      
    for (String s : args)
        frequencyTable.merge(s, 1, (count, incr) -> count + incr); // 람다
    System.out.println(frequencyTable);

    frequencyTable.clear();
    for (String s : args)
        frequencyTable.merge(s, 1, Integer::sum); // 메서드 참조
    System.out.println(frequencyTable);
  }
}
```

람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다. 즉, 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다. 

메서드 참조의 유형은 다섯 가지로, 가장 흔한 유형은 정적 메서드를 가리키는 메서드 참조이다.

- 한정적 인스턴스 메서드
  - 수신 객체(참조 대상 인스턴스)를 특정. 근본적으로 정적 참조와 비슷
  - 함수 객체가 받는 인수와 참조되는 인수가 받는 인수가 똑같다
- 비한정적 인스턴스 메서드
  - 수신 객체를 특정하지 않는 참조
  - 함수 객체를 적용하는 시점에 수신 객체를 알려준다
    - 이를 위해 수신 개게 전달용 매개변수가 매개변수 목록의 첫번째로 추가되며 그 뒤로 참조되는 매개변수들이 뒤따른다 
  - 주로 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다 

:exclamation: 다섯가지 메서드 참조

| 메서드 참조유형    | 예                   | 같은 기능을 하는 람다          |
| ------------------ | -------------------- | ------------------------------ |
| 정적               | Integer::parseInt    | str -\> Integer.parseInt(str)  |
| 한정적(인스턴스)   | Instant.now()::isAfter | Instant then = Instant.now(); <br/> t -> then.isAfter(t) |
| 비한정적(인스턴스) | String::toLowerCase  | str -> str.toLowerCase() |
| 클래스 생성자      | TreeMap<K,V>::new    | () -> new TreeMap<K,V>() |
| 배열 생성자        | int[]::new           | len -> new int[len]      |



## 44) `표준 함수형 인터페이스`를 사용하라 

자바가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었다. 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것이다. 즉, 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들어야 한다.

LinkedHashMap 을 생각해보면, removeEldestEntry 를 다음처럼 재정의하면 맵에 원소가 100개가 될 때까지 커지다가 그 이상이 되면 가장 오래된 원소를 하나씩 제거한다. (가장 최근 원소 100개를 유지한다)

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
  return size() > 100;
}

//////////////////////////////

// ** 참고 https://www.geeksforgeeks.org/linkedhashmap-removeeldestentry-method-in-java/

// Creating the linked hashmap and implementing 
// removeEldestEntry() to MAX size 
LinkedHashMap<Integer, String> li_hash_map =  
    new LinkedHashMap<Integer, String>() { 
        protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) { 
            return size() > MAX;    // MAX = 6
        } 
    }; 
```

> 코드 44-1 불필요한 함수형 인터페이스 - 대신 표준 함수형 인터페이스를 사용하라

```java
@FunctionalInterface interface EldestEntryRemovalFunction<K,V> {
    boolean remove( Map<K,V> map, Map.Entry<K,V> eldest );
}

// 표준 인터페이스인 BiPredicate<Map<K,V>, Map.Entry<K,V>> 를 사용할 수도 있다 
```

:hand: @FunctionalInterface 애너테이션을 사용하는 이유

- 그 인터페이스가 람다용으로 설계된 것임을 알려준다
- 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다
- 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다

#### :arrow_right: 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라

java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 담겨 있다.

#### :arrow_right: 필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.

- API 가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다
- 다른 코드와의 상호운용성도 크게 좋아질 것이다

java.util.function 패키지에는 총 43개의 인터페이스가 담겨 있다. 기본 인터페이스 6개만 기억하면 나머지를 유추해 낼 수 있다.

- 기본 인터페이스는 기본 타입인 int, long, double 용으로 각 3개씩 변형이 생겨난다
  - ex: IntPredicate, DoubleBinaryOperator, LongFuntion\<int\[\]\>
- Function 인터페이스의 입력과 출력은 'To'로 연결 
  - ex: LongToIntFunction, ToLongFunction\<int\[\]\>
- 인수를 두개씩 받는 변형 3가지
  - ex: BiPredicate\<T,U\>, BiFunction\<T,U,R\>, BiConsumer\<T,U\>
- boolean 명시한 유일한 인터페이스 : BooleanSupplier

| 인터페이스           | 함수 시그니처        | 예               |       
| -------------------- | -------------------- | ---------------- |
| BinaryOperator\<T\>  | T apply(T t1, T t2)  | BigInteger::add  |
| Predicate\<T\>  | boolean test(T t)  | Collection::isEmpty  |
| Function\<T,R\>  | R apply(T t)  | Arrays::asList  |
| Supplier\<T\>  | T get()  | Instant::now  |
| Consumer\<T\>  | void accept(T t)  | System.out::println  |

:exclamation: *_기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자_* (처참히 느려질 수 있다)

Comparator\<T\> 인터페이스는 구조적으로 ToIntBiFunction\<T,U\>와 동일하다.

> 그러나 Comparator 가 독자적인 인터페이스로 살아남아야 하는 이유

- API 에서 자주 사용되는데, 이름이 용도를 훌륭히 설명해준다
- 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있다
- 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드들을 듬뿍 담고 있다

## 45) `스트림`은 주의해서 사용하라 

```java
// 반복 방식과 스트림 방식으로 두 리스트의 데카르트 곱을 생성한다. (275-276쪽)
public class Card {
    public enum Suit { SPADE, HEART, DIAMOND, CLUB }
    public enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN,
                       EIGHT, NINE, TEN, JACK, QUEEN, KING }

    private final Suit suit;
    private final Rank rank;

    @Override public String toString() {
        return rank + " of " + suit + "S";
    }

    public Card(Suit suit, Rank rank) {
        this.suit = suit;
        this.rank = rank;

    }
    private static final List<Card> NEW_DECK = newDeck();

    // 코드 45-4 데카르트 곱 계산을 반복 방식으로 구현 (275쪽)
    private static List<Card> newDeck() {
        List<Card> result = new ArrayList<>();
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                result.add(new Card(suit, rank));
        return result;
    }

//    // 코드 45-5 데카르트 곱 계산을 스트림 방식으로 구현 (276쪽)
//    private static List<Card> newDeck() {
//        return Stream.of(Suit.values())
//                .flatMap(suit ->
//                        Stream.of(Rank.values())
//                                .map(rank -> new Card(suit, rank)))
//                .collect(toList());
//    }

    public static void main(String[] args) {
        System.out.println(NEW_DECK);
    }
}
```

```java
// char 데이터를 처리할 때는 스트림 사용을 자제하자. (272쪽)
public class CharStream {
    public static void main(String[] args) {
        // 예상한 결과와 다르다.
        "Hello world!".chars().forEach(System.out::print);
        System.out.println();

        // 문제를 고치려면 형변환을 명시적으로 해줘야 한다.
        "Hello world!".chars().forEach(x -> System.out.print((char) x));
        System.out.println();
    }
}
```

```java
// 스트림을 사용해 처음 20개의 메르센 소수를 생성한다. (274쪽)
public class MersennePrimes {
    static Stream<BigInteger> primes() {
        return Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }

    public static void main(String[] args) {
        primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
                .filter(mersenne -> mersenne.isProbablePrime(50))
                .limit(20)
                .forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
    }
}
```

```java
// 코드 45-3 스트림을 적절히 활용하면 깔끔하고 명료해진다. (271쪽)
public class HybridAnagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> alphabetize(word)))
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .forEach(g -> System.out.println(g.size() + ": " + g));
        }
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

```java
// 코드 45-1 사전 하나를 훑어 원소 수가 많은 아나그램 그룹들을 출력한다. (269-270쪽)
public class IterativeAnagrams {
    public static void main(String[] args) throws IOException {
        File dictionary = new File(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();
                groups.computeIfAbsent(alphabetize(word),
                        (unused) -> new TreeSet<>()).add(word);
            }
        }

        for (Set<String> group : groups.values())
            if (group.size() >= minGroupSize)
                System.out.println(group.size() + ": " + group);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

```java
// 코드 45-2 스트림을 과하게 사용했다. - 따라 하지 말 것! (270-271쪽)
public class StreamAnagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                    groupingBy(word -> word.chars().sorted()
                            .collect(StringBuilder::new,
                                    (sb, c) -> sb.append((char) c),
                                    StringBuilder::append).toString()))
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .map(group -> group.size() + ": " + group)
                    .forEach(System.out::println);
        }
    }
}
```

## 46) 반환 타입으로는 스트림보다 `컬렉션`이 낫다 

```java
// 빈도표 초기화에 스트림을 적절하지 못하게 혹은 적절하게 사용하는 예 (277-279쪽)
public class Freq {
    public static void main(String[] args) throws FileNotFoundException {
        File file = new File(args[0]);

//        // 코드 46-1 스트림 패러다임을 이해하지 못한 채 API만 사용했다 - 따라 하지 말 것! (277쪽)
//        Map<String, Long> freq = new HashMap<>();
//        try (Stream<String> words = new Scanner(file).tokens()) {
//            words.forEach(word -> {
//                freq.merge(word.toLowerCase(), 1L, Long::sum);
//            });
//        }

        // 코드 46-2 스트림을 제대로 활용해 빈도표를 초기화한다. (278쪽)
        Map<String, Long> freq;
        try (Stream<String> words = new Scanner(file).tokens()) {
            freq = words
                    .collect(groupingBy(String::toLowerCase, counting()));
        }

        System.out.println(freq);

        // 코드 46-3 빈도표에서 가장 흔한 단어 10개를 뽑아내는 파이프라인 (279쪽)
        List<String> topTen = freq.keySet().stream()
                .sorted(comparing(freq::get).reversed())
                .limit(10)
                .collect(toList());

        System.out.println(topTen);
    }
}
```

## 47) `스트림 병렬화`는 주의해서 적용하라 

```java
// 스트림 <-> 반복자 어댑터 (285-286쪽)
public class Adapters {
    // 코드 47-3 Stream<E>를 Iterable<E>로 중개해주는 어댑터 (285쪽)
    public static <E> Iterable<E> iterableOf(Stream<E> stream) {
        return stream::iterator;
    }

    // 코드 47-4 Iterable<E>를 Stream<E>로 중개해주는 어댑터 (286쪽)
    public static <E> Stream<E> streamOf(Iterable<E> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }
}
```

```java
public class PowerSet {
    // 코드 47-5 입력 집합의 멱집합을 전용 컬렉션에 담아 반환한다. (287쪽)
    public static final <E> Collection<Set<E>> of(Set<E> s) {
        List<E> src = new ArrayList<>(s);
        if (src.size() > 30)
            throw new IllegalArgumentException(
                "집합에 원소가 너무 많습니다(최대 30개).: " + s);
        return new AbstractList<Set<E>>() {
            @Override public int size() {
                // 멱집합의 크기는 2를 원래 집합의 원소 수만큼 거듭제곱 것과 같다.
                return 1 << src.size();
            }

            @Override public boolean contains(Object o) {
                return o instanceof Set && src.containsAll((Set)o);
            }

            @Override public Set<E> get(int index) {
                Set<E> result = new HashSet<>();
                for (int i = 0; index != 0; i++, index >>= 1)
                    if ((index & 1) == 1)
                        result.add(src.get(i));
                return result;
            }
        };
    }

    public static void main(String[] args) {
        Set s = new HashSet(Arrays.asList(args));
        System.out.println(PowerSet.of(s));
    }
}
```

```java
// 리스트의 모든 부분리스트를 원소를 갖는 스트림을 생성하는 두 가지 방법 (288-289쪽)
public class SubLists {
    // 코드 47-6 입력 리스트의 모든 부분리스트를 스트림으로 반환한다. (288-289쪽)
    public static <E> Stream<List<E>> of(List<E> list) {
        return Stream.concat(Stream.of(Collections.emptyList()),
                prefixes(list).flatMap(SubLists::suffixes));
    }

    private static <E> Stream<List<E>> prefixes(List<E> list) {
        return IntStream.rangeClosed(1, list.size())
                .mapToObj(end -> list.subList(0, end));
    }

    private static <E> Stream<List<E>> suffixes(List<E> list) {
        return IntStream.range(0, list.size())
                .mapToObj(start -> list.subList(start, list.size()));
    }

//    // 코드 47-7 입력 리스트의 모든 부분리스트를 스트림으로 반환한다(빈 리스트는 제외). (289쪽)
//    // 289쪽의 명확한 반복 코드의 변형이다.
//    public static <E> Stream<List<E>> of(List<E> list) {
//        return IntStream.range(0, list.size())
//                .mapToObj(start ->
//                        IntStream.rangeClosed(start + 1, list.size())
//                                .mapToObj(end -> list.subList(start, end)))
//                .flatMap(x -> x);
//    }

    public static void main(String[] args) {
        List<String> list = Arrays.asList(args);
        SubLists.of(list).forEach(System.out::println);
    }
}
```

```java
// 병렬 스트림을 사용해 처음 20개의 메르센 소수를 생성하는 프로그램 (291쪽 코드 48-1의 병렬화 버전)
// 주의: 병렬화의 영향으로 프로그램이 종료하지 않는다.
public class ParallelMersennePrimes {
    public static void main(String[] args) {
        primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
                .parallel() // 스트림 병렬화
                .filter(mersenne -> mersenne.isProbablePrime(50))
                .limit(20)
                .forEach(System.out::println);
    }

    static Stream<BigInteger> primes() {
        return Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }
}
```

```java
public class ParallelPrimeCounting {
    // 코드 48-3 소수 계산 스트림 파이프라인 - 병렬화 버전 (295쪽)
    static long pi(long n) {
        return LongStream.rangeClosed(2, n)
                .parallel()
                .mapToObj(BigInteger::valueOf)
                .filter(i -> i.isProbablePrime(50))
                .count();
    }

    public static void main(String[] args) {
        System.out.println(pi(10_000_000));
    }
}
```
