---
title: "Effective Java 3rd - Ch03"
date: 2019-03-13 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제3장 모든 객체의 공통 메서드

- Object 의 final 이 아닌 메서드 : equals, hashCode, toString, clone, finalize
- 재정의 시 지켜야 하는 일반 규약 설명
- 언제 어떻게 재정의해야 하는지 설명
- finalize 는 8번 항목에서 다뤘으므로 제외. Comparable.compareTo 는 포함


## 10) equals 는 일반 규약을 지켜 재정의 하라

다음 사항에 해당된다면 equals 메서드는 재정의 하지 않는게 좋다.

- 각 인스턴스가 본질적으로 `고유`하다
- 인스턴스의 `논리적 동치성`을 검사할 일이 없다
- 상위 클래스에서 재정의한 equals 가 하위 클래스에도 적합하다
- 클래스가 private 이거나 package-private 이고, equals 메서드를 호출할 일이 없다

> equals 메서드는 동치관계를 구현하며, 다음을 만족해야 한다 (규약)

- null-아님 : x.equals(null) == false
- 반사성(reflexivity) : x.equals(x) == true
- 대칭성(symmetry) : x.equals(y) == true 이면 y.equals(x) == true
- 추이성(transitivity) : x.equals(y) == true 이고 y.equals(z) == true 이면 x.equals(z) == true
- 일관성(consistency) : x.equals(x) == true 를 반복해서 호출해도 항상 true 또는 false
  - equals 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다
  - 항시 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다

> 코드 10-1 잘못된 코드 : 대칭성 위배

```java
public final class CaseInsensitiveString {
  private final String s;

  public CaseInsensitiveString(String s) {
    this.s = Objects.requiredNonNull(s);
  }

  // 대칭성 위배! 한 방향으로만 동치 비교
  @Override
  public boolean equals(Object o) {
    if( o instanceof CaseInsensitiveString)
      return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s );
    if( o instanceof String )
      return s.equalsIgnoreCase( (String) o );
    return false;
  }

  /*
  // String 과도 비교하겠다는 허황된 꿈을 버려야 한다
  @Override
  public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &&
        ((CaseInsensitiveString) o).s.equalsIgnoreCase(this.s);
  }
  */
}

/////////////////////

CaseInsensitiveString cis = new CaseInsensitiveString("polish");
String s = "polish";

cis.equals(s) == true   // OK
s.equals(cis) != true   // wrong!
```

```diff
- equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다
```

> 코드 10-2 잘못된 코드 : 대칭성 위배

```java
@Override
public boolean equals(Object o) {
  if( !(o instanceof ColorPoint) )
    return false;
  return super.equals(o) && ((ColorPoint) o).color == color;
}

////////////////////////

Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED);

p.equals(cp) == true;
cp.equals(p) != true;  // 클래스 종류가 다르다고 false 반환
```

> 코드 10-3 잘못된 코드 : 추이성 위배

```java
@Override
public boolean equals(Object o) {
  if( !(o instanceof Point) )
    return false;

  // o 가 일반 Point 면 색상을 무시하고 비교한다
  if( !(o instanceof ColorPoint) )
    return o.equals(this);

  // o 가 ColorPoint 면 색상까지 비교한다
  return super.equals(o) && ((ColorPoint) o).color == this.color;
}

////////////////////////

ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);

p1.equals(p2) == true && p2.equals(p3) == true;
p1.equals(p3) != true  // color 가 다르다고 false 반환
```

구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.

> 코드 10-4 잘못된 코드 : 리스코프 치환 원칙 위배

```java
@Override
public boolean equals(Object o) {
  if( o == null || o.getClass() != getClass() )
    return false;
  Point p = (Point) o;
  return p.x == x && p.y == y;
}

// 괜찮아 보이지만 실제로 활용할 수는 없다
// Point 하위 클래스는 정의상 Point 이므로 어디서든 Point 로서 활용될 수 있어야 한다  
```

#### :heavy_exclamation_mark: 리스코프 치환 원칙

어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다. 따라서 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 작동해야 한다.

> 코드 10-5 equals 규약을 지키면서 값 추가하기

```java
public class ColorPoint {
  private final Point point;
  private final Color color;

  public ColorPoint(int x, int y, Color color) {
    point = new Point(x, y);
    this.color = Objects.requiredNonNull(color);
  }

  // '항목 18' 참조 : 상속 대신 컴포지션을 사용하라
  // 이 ColorPoint 의 Point 뷰를 반환한다
  public Point asPoint() {
    return point;
  }

  @Override
  public boolean equals(Object o) {
    if( !(o instanceof ColorPoint))
      return false;
    ColorPoint cp = (ColorPoint) o;
    return cp.point.equals(point) && cp.color.equals(color);
  }
}
```

#### :heavy_exclamation_mark: equals 메소드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다
3. 입력을 올바른 타입으로 형변환 한다
4. 입력 객체와 자기 자신의 대응되는 `핵심`필드들이 모두 일치하는지 하나씩 검사한다
5. 어떤 필드를 먼저 비교하느냐에 따른 성능(비용) 문제도 고민한다  

> 코드 10-6 전형적인 equals 메서드의 예

```java
public final class PhoneNumber {
  private final short areaCode, prefix, lineNum;

  public PhoneNumber(int areaCode, int prefix, int lineNum) {
    this.areaCode = rangeCheck(areaCode, 999, "지역코드");
    this.prefix = rangeCheck(prefix, 999, "프리픽스");
    this.lineNum = rangeCheck(lineNum, 999, "가입자 번호");
  }

  private static short rangeCheck(int val, int max, String arg) {
    if( val < 0 || val > max )
      throw new IllegalArgumentException(arg + ": " + val);
    return (short) val;
  }

  @Override
  public boolean equals(Object o) {
    if( o == this )
      return true;
    if( !(o instanceof PhoneNumber))
      return false;
    PhoneNumber pn = (PhoneNumber) o;
    return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode == areaCode;
  }
}
```

> 주의사항

```diff
- equals 를 재정의 할 땐 hasCode 도 반드시 재정의 하자
- 너무 복잡하게 해결하려 들지 말자
- Object 외의 타입을 매개변수를 받는 equals 는 만들지 말자
- - ex) equals(MyClass o) : `재정의`가 아니라 `다중정의`이다!
````

### 11) equals 를 재정의 하려거든 hasCode 도 재정의 하라

> 코드 2-1 점층적 생성자 패턴 - 확장하기 어렵다

```java

```

## 12) toString 을 항상 재정의 하라

```java
```

## 13) clone 재정의는 주의해서 진행하라

```java
```

## 14) Comparable 을 구현할지 고려하라 

```java
```

