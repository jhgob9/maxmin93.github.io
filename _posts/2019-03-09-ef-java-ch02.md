---
title: "Effective Java 3rd - Ch02"
date: 2019-03-09 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

## 제2장 객체 생성과 파괴

- 객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 법
- 올바른 객체 생성 방법
- 불필요한 생성을 피하는 방법
- 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령


### 1) 생성자 대신 정적 팩토리 메서드를 고려하라

> 코드 2-0 디자인 패턴의 팩토리 메소드와 다르다

```java
public static Boolean valueOf( boolean b ){
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

#### 장점

- 이름을 가질 수 있다 : 충분한 설명 
- 호출될 때마다 인스턴스를 새로 생성하지 않아도 됨 : [플라이웨이트 패턴](https://ko.wikipedia.org/wiki/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8_%ED%8C%A8%ED%84%B4)과 유사
- 반환 타입의 하위타입 객체를 반환할 수 있음 : 유연성 
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음 
- 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨
  - ex) JDBC : 서비스 인터페이스, 제공자 등록 API, 서비스 접근 API 

#### 단점 

- 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다 
- 정적 팩토리 메서드는 프로그래머가 찾기 어렵다 


### 2) 생성자에 매개변수가 많다면 빌더를 고려하라

> 코드 2-1 점층적 생성자 패턴 - 확장하기 어렵다

```java
public class NutritionFacts {
  private final int servingSize;      // 필수
  private final int servings;         // 필수
  private final int calories;         // 선택
  private final int fat;              // 선택
  private final int sodium;           // 선택
  private final int carbohydrate;     // 선택

  public NutritionFacts( int servingSize, int servings ){
    this( servingSize, servings, 0 );
  }
  
  public NutritionFacts( int servingSize, int servings, int calories ){
    this( servingSize, servings, calories, 0 );
  }

  public NutritionFacts( int servingSize, int servings, int calories
        , int fat ){
    this( servingSize, servings, calories, fat, 0 );
  }

  public NutritionFacts( int servingSize, int servings, int calories
        , int fat, int sodium ){
    this( servingSize, servings, calories, fat, sodium, 0 );
  }

  public NutritionFacts( int servingSize, int servings, int calories
        , int fat, int sodium, int carbohydrate ){
    this.servingSize = servingSize;
    this.servings = servings;
    this.calories = calories;
    this.fat = fat;
    this.sodium = sodium; 
    this.carbohydrate = carbohydrate;
  }

}

/////////////////////

NutritionFacts cocaCola = new NutritionFacts( 240, 8, 100, 0, 35, 27 );

```

> 코드 2-2 자바빈즈 패턴 : 일관성이 깨지고, 불변(immutable)으로 만들 수 없다 

```java
public class NutritionFacts {
  // 매개변수들은 기본값으로 초기화 된다 
  private int servingSize  = -1;    // 필수 
  private int servings     = -1;    // 필수 
  private int calories     = 0;
  private int fat          = 0;
  private int sodium       = 0;
  private int carbohydrate = 0;

  public NutritionFacts() {}
  // setter methods
  public void setServingSize(int val)  { servingSize = val; }
  public void setServings(int val)     { servings = val; }
  public void setCalories(int val)     { calories = val; }
  public void setFat(int val)          { fat = val; }
  public void setSodium(int val)       { sodium = val; }
  public void setCarbohydrate(int val) { carbohydrate = val; }

  // 일단 생성하고 내부변수를 채우는 전략
  // ==> 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 됨 
}
```

> 코드 2-3 빌더 패턴 : 점층적 생성자 패턴과 자바빈즈 패턴의 장점만 취했다 

```java
public class NutritionFacts {
  private final int servingSize;
  private final int servings;
  private final int calories;
  private final int fat;
  private final int sodium;
  private final int carbohydrate;

  public static class Builder {
    // 필수 매개변수 
    private final int servingSize;
    private final int servings;

    // 선택 매개변수 : 기본값으로 초기화 
    private int calories     = 0;
    private int fat          = 0;
    private int sodium       = 0;
    private int carbohydrate = 0;

    public Builder(int servingSize, int servings){
      this.servingSize = servingSize;
      this.servings = servings;
    }

    public Builder calories(int val){
      this.calories = val; return this;
    }
    public Builder fat(int val){
      this.fat = val; return this;
    }
    public Builder sodium(int val){
      this.sodium = val; return this;
    }
    public Builder carbohydrate(int val){
      this.carbohydrate = val; return this;
    }

    public NutritionFacts build(){
      return new NutritionFacts(this);
    }
  }

  private NutritionFacts(Builder builder){
    this.servingSize = builder.servingSize;
    this.servings = builder.servings;
    this.calories = builder.calories;
    this.fat = builder.fat;
    this.sodium = builder.sodium; 
    this.carbohydrate = builder.carbohydrate;
  }
}

/////////////////////

// NOTE: 쓰기 쉽고, 무엇보다 읽기 쉽다 
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
          .calories(100).sodium(35).carbohydrate(27).build();
```

> 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다 

코드 2-4 계층적으로 설계된 클래스와 잘 어울리는 빌더 패턴 
```java
public abstract class Pizza {
  public enum Topping { HAM, MUSHROOM, INION, PEPPER, SAUSAGE }
  final Set<Topping> toppings;

  // 재귀적 타입 한정을 이용하는 제네릭 타입 
  abstract static class Builder<T extends Builder<T>> {
    EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
    public T addTopping(Topping topping) {
      toppings.add(Objects.requireNonNull(topping));
      return self();    // 자신을 가리키는 추상 메서드 (밑에 있음)
    }

    abstract Pizza build();

    // 하위 클래스는 이 메서드를 재정의(overriding) 하여
    // "this"를 반환하도록 해야 한다 
    protected abstract T self();
  }

  Pizza(Builder<?> builder){
    toppings = builder.toppings.clone();
  }
}
```

코드 2-5 뉴욕 피자
```java
public class NyPizza extends Pizza {
  public enum Size { SMALL, MEDIUM, LARGE }
  private final Size size;

  public static class Builder extends Pizza.Builder<Builder> {
    private final Size size;

    public Builder(Size size) {
      this.size = Objects.requireNonNull(size);
    }

    @Override
    public NyPizza build() { return new NyPizza(this); }

    @Override
    protected Builder self() { return this; }
  }

  private NyPizza(Builder builder) {
    super(builder);
    size = builder.size;
  }
}

////////////////////////
NyPizza pizza = new NyPizza.Builder(SMALL)    // 필수 매개변수 
        .addTopping(SAUSAGE).addTopping(ONION).build();
```

코드 2-6 칼초네 피자
```java
public class Calzone extends Pizza {
  private final boolean sauceInside;

  public static class Builder extends Pizza.Builder<Builder> {
    private boolean sauceInside = false;    // 기본값 

    public Builder sauceInside() { 
      sauceInside = true; return this; 
    }

    @Override
    public Calzone build() { return new Calzone(this); }

    @Override
    protected Builder self() { return this; }
  }

  private Calzone(Builder builder) {
    super(builder);
    sauceInside = builder.sauceInside;
  }
}
////////////////////////
Calzone pizza = new Calzone.Builder()     // 필수 없음
        .addTopping(HAM).sauceInside().build();
```

> :heavy_exclamation_mark: 핵심정리 
> 생성자나 정적 팩토리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다 
> 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다 


### 3) private 생성자나 열거 타입으로 싱글턴임을 보증하라

```java
```

### 4) 인스턴스화를 막으려거든 private 생성자를 사용하라

```java
```

### 5) 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

```java
```

### 6) 불필요한 객체 생성을 피하라

```java
```

### 7) 다 쓴 객체 참조를 해제하라

```java
```

### 8) finalizer 와 cleaner 사용을 피하라

```java
```

### 9) try-finally 보다는 try-with-resources 를 사용하라

```java
```

