---
title: "Effective Java 3rd - Ch05"
date: 2019-03-20 20:12:00 -0400
categories: java til
---

* 출처 : 도서 [Effective Java 3rd](http://www.yes24.com/Product/Goods/65551284)

# 제5장 제네릭

- 제네릭은 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다 
- 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단 
- 코드가 복잡해진다는 단점 
- 제네릭의 이점을 최대로 살리고 단점을 최소화하는 방법을 소개


## 26) `RAW 타입`은 사용하지 말라

제네릭 클래스와 제네릭 인터페이스를 통틀어 `제네릭 타입`이라고 함 

- 제네릭 타입은 일련의 매개변수화 타입을 정의한다, ex) List<String>
- 제네릭 타입을 정의하면 그에 딸린 `raw 타입`도 함께 정의된다
	- ex) List<E> 의 raw 타입은 List
- 제네릭 타입은 형변환에 있어 절대 실패하지 않음을 보장
	- 컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가 
- 호환성 문제 때문에 매개변수가 없는 raw 타입을 남겨두긴 했지만 절대 써서는 안됨

> 코드 26-3 매개변수화 된 컬렉션 타입 - 타입 안정성 확보

```java
private final Collecction<Stamp> stamp = ...;
```

```diff
- List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 raw 타입을 사용하면 타입 안정성을 잃게 된다 
```

> 코드 26-4 런타임에 실패한다 - unsafeAdd 메서드가 raw 타입(List)을 활용

```java
public static void main(String[] args) {
	List<String> strings = new ArrayList<>();
	unsafeAdd(strings,, Integer.valueOf(42));
	String s = strings.get(0);		// 컴파일러가 자동으로 형변환 코드를 넣어준다 
}

private static void unsafeAdd(List list, Object o) {
	list.add(o);
}

/*
// 컴파일은 되지만 다음과 같은 경고가 발생한다
Test.java:10: warning: [unchecked] unchecked ccall to add(E) as a memeber of the raw type List
  --> list.add(o);

// List를 List<Object>로 바꾸고 컴파일하면 컴파일 조차 되지 않는다
Test.java:5: error: inccompatible types: List<String> cannot be cconverted to List<Object>
	--> unsafeAdd(strings, Integer.valueOf(42));
*/
```

> 코드 26-5 잘못된 예 - 모르는 타입의 원소도 받는 raw 타입을 사용했다

```java
// 동작은 하지만 raw 타입을 사용해 안전하지 않다 
static int numElementsInCommon(Set s1, Set s2) {
	int result = 0;
	for( Object o1 : s1 )
		if( s2.contains(o1) )
			result++;
	return result;
}
```

이런 경우엔 `와일드카드 타입`을 사용하는게 좋다. ==> Set<?>

- Collection<?> 에는 (null 외에는) 어떤 원소도 넣을 수 없다 
- 어쨌든 컬렉션의 타입 불변식을 훼손하지 못하게 막는다
- 이러한 제약을 받아들 수 없다면 제네릭 메서드나 한정적 와일드카드 타입을 사용하면 된다

> 코드 26-6 비한정적 와일드카드 타입을 사용하라 - 타입에 안전하며 유연하다 

```java
static int numElementsInCommon( Set<?> s1, Set<?> s2 ){ ... }
```

> 코드 26-7 raw 타입을 써도 좋은 예 - instanceof 연산자 

```java
// o의 타입이 Set 임을 확인한 다음 Set<?> 로 형변환해야 한다
if( o instanceof Set ){			// raw 타입
	Set<?> s = (Set<?>) o;		// 와일드카드 타입 (컴파일러 경고가 뜨지 않는다)
}
```

:heavy_exclamation_mark: 용어 정리

| 한글용어         | 영문용어        | 예 	  					| 관련항목 	|
| ---------------- |:---------------:|:----------------:|----------:|
| 매개변수화 타입  | parameterized type  | List<String>  | 항목26  |
| 실제 타입 매개변수  | actual type parameter  | String  | 항목26  |
| 제네릭 타입  | generic type  | List<E>  | 항목26,29  |
| 정규타입 매개변수  | formal type parameter  | E  | 항목26  |
| 비한정적 와일드카드 타입  | unbounded wildcard type  | List<?>  | 항목26  |
| 로 타입  | raw 타입  | List  | 항목26  |
| 한정적 타입 매개변수  | bounded type parameter  | <E extends Number>  | 항목29  |
| 재귀적 타입 한정  | recursive type bound  | <T extends Comparable<T>>  | 항목30  |
| 한정적 와일드카드 타입  | bounded wildcard type  | List<? extends Number>  | 항목템31  |
| 제네릭 메서드  | generic method  | static <E> List<E> asList(E[] a)  | 항목30  |
| 타입 토큰  | type token  | String.class  | 항목33 |



## 27) `비검사 경고`를 제거하라

제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될 것이다.

```java
// unchecked conversion 경고가 뜬다
Set<Lark> exaltation = new HashSet();

// **해결 ==>
// 자바 7부터 지원하는 다이아몬드 연산자(<>)만으로 해결할 수 있다
Set<Lark> exaltation = new HashSet<>();
```

```diff
- 할 수 있는 한 모든 비검사 경고를 제거하라!
```

경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 

- @SuppressWarnings("unchecked") 애너테이션을 달아 경고를 숨기자
- @SuppressWarnings 애너테이션은 항상 좁은 범위에 적용하자 
- @SuppressWarnings 애너테이션을 사용할 때면 그 이유를 항상 주석으로 남겨야 한다 

> 코드 27-1 지역변수를 추가해 @SuppressWarnings 의 범위를 좁힌다

```java
public <T> T[] toArray(T[] a) {
	if( a.length < size ){
		// 생성한 배열과 매개변수로 받은 배열의 타입이 모두 T[] 로 같으므로 
		// 올바른 형변환이다
		@SuppressWarnings("unchecked") T[] result =
				(T[]) Arrays.copyOf(elements, size, a.getClass());
		return result;
	}
	System.arraycopy(elements, 0, a, 0, size);
	if( a.length > size )
		a[size] = null;
	return a;
}
```



## 28) 배열보다는 `리스트`를 사용하라

배열과 제네릭 타입의 중요한 차이 2가지

- 배열은 공변(covariant)이다. 반면 제네릭은 불공변
	- 배열 : Sub 가 Super 의 하위타입이라면 배열 Sub[] 는 배열 Super[] 의 하위타입
	- 제네릭 : Type1 과 Type2 가 있을 때, List<Type1> 은 List<Type2> 와 호환되지 않는다 
- 배열은 실체화(reify) 된다 
	- 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다 (코드 28-1)
	- 제네릭은 타입 정보가 런타임에는 소거된다 (컴파일 타임에만 검사)

> 코드 28-1 런타임에 실패한다

```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다";		// ArrayStoreException
```

> 코드 28-2 컴파일이 되지 않는다

```java
List<Object> ol = new ArrayList<Long>();		// 호환되지 않는 타입
ol.add("타입이 달라 넣을 수 없다");
```

배열과 제네릭은 잘 어울어지지 못하며, 타입 안전을 위해 제네릭 배열을 만들지 못하게 막았다.

> 코드 28-3 제네릭 배열 생성을 허용하지 않는 이유 - 컴파일 되지 않는다

```java
List<String>[] stringLists = new List<String>[1];		// 이것이 허용된다면??
Object[] objects = stringLists;

List<Integer> intList = List.of(42);
objects[0] = intList;								// 뒤죽박죽

String s = stringLists[0].get(0);		// List<String>이 아니라 List<Integer> 가 꺼내짐
```

생성자에서 컬렉션을 받는 Chooser 클래스를 예로 살펴보자

> 코드 28-4 Chooser - 제네릭을 시급히 적용해야 한다

```java
public class Chooser {
	private final Object[] choiceArray;

	public Chooser(Collection choices) {
		choiceArray = choices.toArray();
	}

	// choose 호출시마다 반환된 Object를 형변환해야 한다 
	public Object choose() {
		Random rnd = ThreadLocalRandom.current();
		return choiceArray[rnd.nextInt(choiceArray.length)];
	}
}
```

> 코드 28-5 Chooser 를 제네릭으로 만들기 위한 첫 시도 - 컴파일 되지 않는다

```java
public class Chooser<T> {
	private final T[] choiceArray;

	public Chooser(Collection<T> choices) {
		choiceArray = choices.toArray();					// <<-- 1) 컴파일 오류
		// 1) 오류로 타입 캐스팅을 했으나
		// choiceArray = (T[]) choices.toArray();	// <<-- 2) 형변환 경고
		// 2) 경고에도 불구하고 동작은 한다. 그러나 타입 안전은 보장 못함
	}

	... // choose 메서드는 그대로
}
```

> 코드 28-6 리스트 기반 Chooser - 타입 안전성 확보

```java
public class Chooser<T> {
	private final List<T> choiceList;

	public Chooser(Collection<T> choices) {
		choiceList = new ArrayList<>(choices);
	}

	// choose 호출시마다 반환된 Object를 형변환해야 한다 
	public T choose() {
		Random rnd = ThreadLocalRandom.current();
		return choiceList.get(rnd.nextInt(choiceList.size()));
	}
}
```

코드의 양은 조금 늘었고 아마도 조금 더 느릴 테지만, 그만한 가치가 있다.



## 29) 이왕이면 `제네릭 타입`으로 만들어라

```java
```

## 30) 이왕이면 `제네릭 메서드`로 만들어라 

```java
```

## 31) `한정적 와일드 카드`를 사용해 API 유연성을 높여라 

```java
```

## 32) 제네릭과 `가변인수`를 함께 쓸 때는 신중하라 

```java
```

## 33) `타입 안전 이종 컨테이너`를 고려하라 

```java
```

